### 线性回归的从零开始实现
* 导入本节中实验所需的包或模块，其中的matplotlib包可用于作图，且设置成嵌入显示。
```python
#导包
%matplotlib inline
from IPython import display
from matplotlib import pyplot as plt
from mxnet import autograd, nd
import random
```
#### 生成数据集
训练数据集样本数为`1000`,输入个数（特征数）为`2`，给定随机生成的批量样本特征$\boldsymbol{X} \in \mathbb{R}^{1000 \times 2}$，使用线性回归模型真实权重$\boldsymbol{w} = [2, -3.4]^\top$和偏差$b = 4.2$，以及一个随机噪声项$\epsilon$来生成标签。
$$\boldsymbol{y} = \boldsymbol{X}\boldsymbol{w} + b + \epsilon,$$
```python
#输入个数：2
num_inputs = 2
#训练数据集样本数：1000
num_examples = 1000
#真实权重2，-3.4
true_w = [2, -3.4]
#真实偏置4.2
true_b = 4.2
```
```python
mxnet.ndarray.random.normal(loc=0, scale=1, shape=_Null, dtype=_Null, ctx=None, out=None, **kwargs)
#生成随机的样本满足高斯分布
Draw random samples from a normal (Gaussian) distribution.
#参数
Parameters：
#期望:正态分布的中心
loc (float or NDArray, optional) – Mean (centre) of the distribution.
#标准差
scale (float or NDArray, optional) – Standard deviation (spread or width) of the distribution.
#生成的样本的shape(形状)
shape (int or tuple of ints, optional) – The number of samples to draw. 
```

```python
#features 就是随机生成的批量样本特征，即上文的$X$，
features = nd.random.normal(scale=1, shape=(num_examples, num_inputs))
```

```python
#以上文的函数生成标签
labels = true_w[0] * features[:, 0] + true_w[1] * features[:, 1] + true_b
#加上噪声
labels += nd.random.normal(scale=0.01, shape=labels.shape)
print(labels.shape)
print(features.shape)
```
#### 读取数据集
在训练模型的时候，我们需要遍历数据集并不断读取小批量数据样本。这里我们定义一个函数：它每次返回`batch_size`（批量大小）个随机样本的特征和标签。
```python
# 本函数已保存在d2lzh包中方便以后使用
def data_iter(batch_size, features, labels):
    #len(features) = 1000,就是数据集的大小，声明num_examples = 1000
    num_examples = len(features)
    #使用list生成式，indice = [0,1,2....999]
    indices = list(range(num_examples))
    #打乱生成的indices顺序
    random.shuffle(indices)  # 样本的读取顺序是随机的
    #range(start, stop[, step])，从0开始循环到num_examples = 1000，以batch_size为步长
    for i in range(0, num_examples, batch_size):
        #生成一个nd.array,每个长度是10,这个是之后取出的下标
        j = nd.array(indices[i: min(i + batch_size, num_examples)])
        #take方法：Takes elements from an input array along the given axis.，将j作为下标同时返回feature和label,
        yield features.take(j), labels.take(j)  # take函数根据索引返回对应元素
```
#### 初始化模型参数
将权重初始化成均值为0、标准差为0.01的正态随机数，偏差则初始化成0。
```python
#初始化权重
w = nd.random.normal(scale=0.01, shape=(num_inputs, 1))
#初始化偏置
b = nd.zeros(shape=(1,))
print(b.shape)
print(w.shape)
```
```python
#申请内存
w.attach_grad()
b.attach_grad()
```
#### 定义模型
线性回归的矢量计算表达式的实现。
```python
#Xdotw最后是[10,2] * [2,1] = [10,1] + b 
def linreg(X, w, b):  # 本函数已保存在d2lzh包中方便以后使用
    return nd.dot(X, w) + b
```
#### 定义损失函数
$$\ell^{(i)}(w_1, w_2, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2,$$
```python
#由上文的方程实现，这里的y的shape是(10,),不是(10,1)和y_hat的shape不一样，所以需要reshape一下，这里其实也是计算矢量法的应用，使用矩阵表示可以简化计算
def squared_loss(y_hat, y):  # 本函数已保存在d2lzh包中方便以后使用
    return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2
```
#### 定义优化算法
选用小批量随机梯度下降算法。自动求梯度模块计算得来的梯度是一个批量样本的梯度和。我们将它除以批量大小来得到平均值。
$$
\begin{aligned}
w_1 &\leftarrow w_1 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{ \partial \ell^{(i)}(w_1, w_2, b)  }{\partial w_1} = w_1 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_1^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right),\\
w_2 &\leftarrow w_2 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{ \partial \ell^{(i)}(w_1, w_2, b)  }{\partial w_2} = w_2 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_2^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right),\\
b &\leftarrow b -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \frac{ \partial \ell^{(i)}(w_1, w_2, b)  }{\partial b} = b -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right).
\end{aligned}
$$

```python
#这里的params有两个元素分别是w:[2,1],和b:[1,1]，也就是params[0] = w = [2,1],params[1] = b = [1,1].
def sgd(params, lr, batch_size):  # 本函数已保存在d2lzh包中方便以后使用
    for param in params:
        #这里就是先是计算w[2,1]，再计算b[1,1],直接算出w.grad[2,1],b.grad[1,1]
        param[:] = param - lr * param.grad / batch_size
```
#### 训练模型
在每次迭代中，我们根据当前读取的小批量数据样本（特征$X$和标签$y$），通过调用反向函数`backward`计算小批量随机梯度，并调用优化算法`sgd`迭代模型参数。
```python
#学习率0.03
lr = 0.03
#迭代周期3
num_epochs = 3
#net表明向量表达式
net = linreg
#loss表明平方损失
loss = squared_loss
#循环三次
for epoch in range(num_epochs):  # 训练模型一共需要num_epochs个迭代周期
    # 在每一个迭代周期中，会使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。X
    # 和y分别是小批量样本的特征和标签
    #X,y每批是10个，也就是X[10,2],y[10,]
    for X, y in data_iter(batch_size, features, labels):
        with autograd.record():
            #计算出损失
            l = loss(net(X, w, b), y)  # l是有关小批量X和y的损失
        #l.backward(),这里的l[10,1],变量l并不是一个标量，运行l.backward()将对l中元素求和得到新的变量，再求该变量有关模型参数的梯度。
        l.backward()  # 小批量的损失对模型参数求梯度
        #进行迭代
        sgd([w, b], lr, batch_size)  # 使用小批量随机梯度下降迭代模型参数
    #计算在当前学习到的参数下，对于整个数据集下的损失[1000,1]
    train_l = loss(net(features, w, b), labels)
    #mean():Computes the mean of array elements over given axes.计算平均值，同时转成numpy实例
    print('epoch %d, loss %f' % (epoch + 1, train_l.mean().asnumpy()))
```



